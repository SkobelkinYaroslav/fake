// Code generated by mockgen. DO NOT EDIT.

package mocks

import (
	"fmt"
	mockSetup "github.com/sonalys/fake/boilerplate"
	"testing"
	"time"
)

type StubInterface[T comparable] struct {
	setupDifferentGenericName mockSetup.Mock[func(a T) time.Time]
	setupWeirdFunc1           mockSetup.Mock[func(a any, b interface {
		A() int
	})]
	setupWeirdFunc2 mockSetup.Mock[func(in *<-chan time.Time, outs ...chan int) error]
	setupEmpty      mockSetup.Mock[func()]
	setupWeirdFunc3 mockSetup.Mock[func(a0 map[T]func(in ...*chan<- time.Time)) T]
}

func NewStubInterface[T comparable](t *testing.T) *StubInterface[T] {
	return &StubInterface[T]{
		setupDifferentGenericName: mockSetup.NewMock[func(a T) time.Time](t),
		setupWeirdFunc1: mockSetup.NewMock[func(a any, b interface {
			A() int
		})](t),
		setupWeirdFunc2: mockSetup.NewMock[func(in *<-chan time.Time, outs ...chan int) error](t),
		setupEmpty:      mockSetup.NewMock[func()](t),
		setupWeirdFunc3: mockSetup.NewMock[func(a0 map[T]func(in ...*chan<- time.Time)) T](t),
	}
}

func (s *StubInterface[T]) AssertExpectations(t *testing.T) bool {
	return s.setupDifferentGenericName.AssertExpectations(t) &&
		s.setupWeirdFunc1.AssertExpectations(t) &&
		s.setupWeirdFunc2.AssertExpectations(t) &&
		s.setupEmpty.AssertExpectations(t) &&
		s.setupWeirdFunc3.AssertExpectations(t) &&
		true
}

func (s *StubInterface[T]) OnDifferentGenericName(funcs ...func(a T) time.Time) mockSetup.Config {
	return s.setupDifferentGenericName.Append(funcs...)
}

func (s *StubInterface[T]) DifferentGenericName(a T) time.Time {
	f, ok := s.setupDifferentGenericName.Call()
	if !ok {
		panic(fmt.Sprintf("unexpected call DifferentGenericName(%v)", a))
	}
	return (*f)(a)
}

func (s *StubInterface[T]) OnWeirdFunc1(funcs ...func(a any, b interface {
	A() int
})) mockSetup.Config {
	return s.setupWeirdFunc1.Append(funcs...)
}

func (s *StubInterface[T]) WeirdFunc1(a any, b interface {
	A() int
}) {
	f, ok := s.setupWeirdFunc1.Call()
	if !ok {
		panic(fmt.Sprintf("unexpected call WeirdFunc1(%v,%v)", a, b))
	}
	(*f)(a, b)
}

func (s *StubInterface[T]) OnWeirdFunc2(funcs ...func(in *<-chan time.Time, outs ...chan int) error) mockSetup.Config {
	return s.setupWeirdFunc2.Append(funcs...)
}

func (s *StubInterface[T]) WeirdFunc2(in *<-chan time.Time, outs ...chan int) error {
	f, ok := s.setupWeirdFunc2.Call()
	if !ok {
		panic(fmt.Sprintf("unexpected call WeirdFunc2(%v,%v)", in, outs))
	}
	return (*f)(in, outs...)
}

func (s *StubInterface[T]) OnEmpty(funcs ...func()) mockSetup.Config {
	return s.setupEmpty.Append(funcs...)
}

func (s *StubInterface[T]) Empty() {
	f, ok := s.setupEmpty.Call()
	if !ok {
		panic(fmt.Sprintf("unexpected call Empty()"))
	}
	(*f)()
}

func (s *StubInterface[T]) OnWeirdFunc3(funcs ...func(a0 map[T]func(in ...*chan<- time.Time)) T) mockSetup.Config {
	return s.setupWeirdFunc3.Append(funcs...)
}

func (s *StubInterface[T]) WeirdFunc3(a0 map[T]func(in ...*chan<- time.Time)) T {
	f, ok := s.setupWeirdFunc3.Call()
	if !ok {
		panic(fmt.Sprintf("unexpected call WeirdFunc3(%v)", a0))
	}
	return (*f)(a0)
}

type AnotherInterface[J any, A any] struct {
	setupDifferentGenericName mockSetup.Mock[func(a J) A]
}

func NewAnotherInterface[J any, A any](t *testing.T) *AnotherInterface[J, A] {
	return &AnotherInterface[J, A]{
		setupDifferentGenericName: mockSetup.NewMock[func(a J) A](t),
	}
}

func (s *AnotherInterface[J, A]) AssertExpectations(t *testing.T) bool {
	return s.setupDifferentGenericName.AssertExpectations(t) &&
		true
}

func (s *AnotherInterface[J, A]) OnDifferentGenericName(funcs ...func(a J) A) mockSetup.Config {
	return s.setupDifferentGenericName.Append(funcs...)
}

func (s *AnotherInterface[J, A]) DifferentGenericName(a J) A {
	f, ok := s.setupDifferentGenericName.Call()
	if !ok {
		panic(fmt.Sprintf("unexpected call DifferentGenericName(%v)", a))
	}
	return (*f)(a)
}
