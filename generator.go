package fake

import (
	"bytes"
	"fmt"
	"go/format"
	"go/parser"
	"go/token"
	"io"
	"os"
	"path"
	"path/filepath"
	"strings"

	"github.com/rs/zerolog/log"
	"golang.org/x/mod/modfile"
)

type Generator struct {
	FileSet *token.FileSet
	PkgName string
}

func NewGenerator(pkgName string) *Generator {
	return &Generator{
		FileSet: token.NewFileSet(),
		PkgName: pkgName,
	}
}

func getRelativePath(path1, path2 string) (string, error) {
	// Make the paths absolute to ensure accurate relative path calculation
	absPath1, err := filepath.Abs(path1)
	if err != nil {
		return "", err
	}
	absPath2, err := filepath.Abs(path2)
	if err != nil {
		return "", err
	}
	// Retrieve the relative path
	relativePath, err := filepath.Rel(filepath.Dir(absPath1), absPath2)
	if err != nil {
		return "", err
	}
	return relativePath, nil
}

// GetPackagePath returns the full package path from a given *ast.File.
func GetPackagePath(fset *token.FileSet, filename string) (string, error) {
	goModPath, err := findFile(filepath.Dir(filename), "go.mod")
	if err != nil {
		return "", err
	}
	// Read the contents of the go.mod file
	modFileContent, err := os.ReadFile(goModPath)
	if err != nil {
		return "", err
	}
	// Parse the go.mod file
	modFile, err := modfile.Parse(goModPath, modFileContent, nil)
	if err != nil {
		return "", err
	}
	// Retrieve the module path
	modulePath := modFile.Module.Mod.Path
	pkgPath, _ := getRelativePath(goModPath, path.Dir(filename))
	return path.Join(modulePath, pkgPath), nil
}

// findFile searches for the go.mod file in the given directory and its parent directories.
func findFile(childDir, filename string) (string, error) {
	for {
		goModPath := filepath.Join(childDir, filename)
		if fileExists(goModPath) {
			return goModPath, nil
		}

		parentDir := filepath.Dir(childDir)
		if parentDir == childDir {
			break
		}
		childDir = parentDir
	}

	return "", fmt.Errorf("go.mod file not found")
}

// fileExists checks if a file exists at the given path.
func fileExists(path string) bool {
	_, err := os.Stat(path)
	return err == nil
}

func (g *Generator) ParseFile(input string) *ParsedFile {
	file, err := parser.ParseFile(g.FileSet, input, nil, parser.ParseComments)
	if err != nil {
		panic(fmt.Sprintf("Error parsing file: %v\n", err))
	}
	pkgPath, _ := GetPackagePath(g.FileSet, input)
	return &ParsedFile{
		Generator:   g,
		Ref:         file,
		PkgPath:     pkgPath,
		PkgName:     file.Name.Name,
		Imports:     ParseImports(file.Imports),
		UsedImports: make(map[string]struct{}),
	}
}

func (g *Generator) WriteFile(input, output string) bool {
	parsedFile := g.ParseFile(input)
	body := bytes.NewBuffer(make([]byte, 0, 2048))
	header := bytes.NewBuffer(make([]byte, 0, 2048))

	interfaces := parsedFile.ListInterfaces()
	if len(interfaces) == 0 {
		return false
	}
	// Iterate through the declarations in the file
	for _, parsedInterface := range interfaces {
		for _, field := range parsedInterface.ListFields() {
			field.UpdateImports()
		}
		parsedInterface.WriteMock(body)
	}

	WriteHeader(header, g.PkgName)
	parsedFile.WriteImports(header)
	// Append body to the header.
	header.Write(body.Bytes())
	// Fetch file buffer.
	b := header.Bytes()
	// Run gofmt in the buffer.
	b = FormatCode(b)
	outputFile := generateOutputFile(input, output)
	outputFile.Write(b)
	outputFile.Close()
	return true
}

func WriteHeader(w io.Writer, packageName string) {
	fmt.Fprintf(w, "// Code generated by mockgen. DO NOT EDIT.\n\n")
	fmt.Fprintf(w, "package %s\n\n", packageName)
}

func FormatCode(in []byte) []byte {
	out, err := format.Source(in)
	if err != nil {
		fmt.Printf("Error formatting file: %v\n", err)
		os.Exit(1)
	}
	return out
}

func generateOutputFile(input, output string) *os.File {
	filename, _ := strings.CutSuffix(path.Base(input), ".go")
	outputFile := path.Join(output, fmt.Sprintf("%s.gen.go", filename))
	outFile, err := CreateFileAndFolders(outputFile)
	if err != nil {
		fmt.Printf("Error creating mock file: %v\n", err)
		os.Exit(1)
	}
	return outFile
}

func Run(inputs []string, output string, ignore []string) {
	gen := NewGenerator("mocks")
	filenames, err := ListGoFiles(inputs, append(ignore, output))
	if err != nil {
		log.Fatal().Msgf("error listing files: %s", err)
	}
	if len(filenames) == 0 {
		log.Info().Msgf("no files found, nothing to be done")
		return
	}
	log.Info().Msgf("scanning %d files", len(filenames))
	for _, filename := range filenames {
		pkg := path.Dir(filename)
		pkg = strings.ReplaceAll(pkg, "internal", "internal_")
		out := path.Join(output, pkg)
		gen.WriteFile(filename, out)
		log.Info().Msgf("digesting %s to %s", filename, out)
	}
}
